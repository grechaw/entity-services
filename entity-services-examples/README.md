# entity-services-examples

This directory contains some examples of how the Entity Services feature 
can be used to integrate data.  Since Entity Services works in consort
with other MarkLogic features, the examples also demonstrate

* Data Movement.  A modern Java library for batch processing of documents with
 MarkLogic
* Template-Driven Extraction.  A method for indexing document data as tuples or
 triples.
* Semantics model integration.  How to integrate entity models with RDF-based
 ones.
* SQL. How to query instance data with SQL.
* Optic API.  A query API for SQL-like access to tuples and triples, with Java,
 XQuery and JavaScript implementations.

There are several kinds of code here in the examples directory.

* A QConsole workspace `races-qc.xml` contains XQuery scripting to work with
 the Entity Services API.
* Examples of code that has been generated, then edited are in directories under 
 `src/main`
* Java classes, with source under `src/main/java` demonstrate use of the Data
 Movement SDK for an Entity Services toolchain.

*Run all commands from this directory.  The example code will not deploy to
MarkLogic if run from the parent project's directory.*

Step One. Deploy
-----------------

`../gradlew mlDeploy` deploys code to a MarkLogic server.  To change the
location of the deployment edit `gradle.properties`

* Databases and forests are provisioned as configured in `src/main/ml-config`.
 Entity services generated the database configuration.
* Entity Services code modules to go from `src/main/ml-modules/ext` to the
 REST extension space.  This code was created from stubs generated by Entity 
 Services.
* Transforms go from `src/main/ml-modules/transforms` to REST config.  These
 transforms wrap calls to the Entity Services modules, but were authored by
 a developer.
* Search options are installed from `src/main/ml-modules/options` to REST.
 This configuration was generated by Entity Services.
* A module to generate code is installed from
 `src/main/ml-modules/services` to REST.  This extension is just used by the
 example code to invoke the Entity Services API as a demonstration.  It was
 written by the examples developer, and isn't part of the example data
 integration per se.
* A schema that can validate canonical instance data is installed from
 `src/main/ml-schemas` to the schemas database.  Entity Services API generated
 this schema out-of-the-box.
* An extraction template that indexes canonical instance data is installed
 from `src/main/ml-schemas` to the schemas database in the proper TDE
 collection.  It is a somewhat modified version of one generated by Entity
 Services.

Step Two.  Run
--------------

`../gradlew run` runs the examples loader.  If you changed deployment
information, check `src/main/resources/application.properties` and edit as
required.

* It loads documents "as-is" from the `data` directory.  When this step is
 complete, the database will have lots of JSON documents as staged data.
* It loads some RDF reference data.
* It invokes an in-place transform batch on the raw documents.  This transform
 invokes code generated by Entity Services to wrap the JSON documents and store
 them in their canonical format.
* Lastly, it actually invokes the code generators and saves the results to the
 `gen` directory.  Note that this step is conceptually distinct from the
 loading and transforming steps.  In a regular workflow, one would generate
 code first, then modify it, deploy, and iterate.

Note that some of these classes have `main` methods of their own in case you
want to run them independently.

Step Three. QConsole
--------------------

A QConsole workspace is included to help you explore what happened in Steps One
and Two.

Import the workspace `races-qc.xml` from QConsole, and step through the tabs,
each of which show something about what your simulated data hub accomplished.

